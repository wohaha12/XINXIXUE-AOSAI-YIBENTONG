# 题目标题：[1320: 【例6.2】均分纸牌(Noip2002)]

## 时间限制: 1000 ms    内存限制: 65536 KB

## 题目难度：⭐⭐

## 算法标签：[贪心、模拟、数学]

## 【题目描述】

有 $n$ 堆纸牌，每堆有若干张，总数是 $n$ 的倍数。允许在相邻堆之间移动纸牌（第1堆只能移给第2堆，第 $n$ 堆只能移给第 $n-1$ 堆）。问最少移动多少次（注意：无论一次移动多少张牌，只要发生了移动，都算作1次），使得每堆纸牌数量相等。

## 【输入】

1. 第一行一个整数 $n$ ($1 \le n \le 100$)。
2. 第二行 $n$ 个整数 $a_1, a_2, \dots, a_n$，表示初始每堆纸牌数。

## 【输出】

一个整数，表示最少移动次数。

## 【输入样例】

```text
4
9 8 17 6
```

## 【输出样例】

```text
3
```

## 🧠 解题思路

1. **步骤一：计算平均值（目标状态）**
    首先求出所有纸牌的总和，除以堆数 $n$，得到最终每堆应该有的纸牌数 `avg`。这是所有操作的目标。

2. **步骤二：贪心策略（从左往右推）**
    * 考虑第 1 堆：它只有右边一个邻居（第 2 堆）。如果第 1 堆不等于 `avg`，它**必须**通过第 2 堆来解决问题。
        * 如果第 1 堆多了，只能把多余的给第 2 堆。
        * 如果第 1 堆少了，只能从第 2 堆拿。
    * 关键点：我们不需要模拟具体的“拿出”或“放入”动作，只需要把**差值**加到下一堆即可。
    * 如果第 1 堆处理完了（此时把它视为已达标，不再碰它），我们面临的就是一个 $n-1$ 堆的子问题，逻辑完全相同。

3. **步骤三：统计次数**
    在遍历过程中，只要当前堆 $a[i]$ 不等于 `avg`，说明必须发生一次移动（无论移动多少张，题目说都算1次）。我们将差额 $a[i] - avg$ 累加到下一堆 $a[i+1]$ 上，并将步数 `ans++`。

## 📊 复杂度分析

* **时间复杂度：O(n)**
    * 解释：我们只需要遍历数组一次（循环 $n-1$ 次），每次操作都是简单的加减法，属于线性时间复杂度。
* **空间复杂度：O(n)**
    * 解释：需要一个数组来存储每一堆纸牌的数量。如果想极致优化，甚至可以只用 $O(1)$ 空间（一边读入一边计算前缀和），但对于 $n=100$ 的数据规模，数组不仅方便而且足够小。

## ⚠️ 易错点与坑点

* **坑点 1：负数的产生**
    * 描述：在代码运行过程中，`cards[i+1] += (cards[i] - avg)` 可能会导致 `cards[i+1]` 暂时变成负数。
    * 解释：这在物理上是不可能的（纸牌数不能为负），但在数学逻辑上是成立的。负数意味着该位置不仅要满足自己的需求，还透支了前面的“债务”，需要后面的堆来填补。不用特判，直接算即可。
* **坑点 2：不需要处理最后一堆**
    * 描述：循环只需要到 $i < n-1$。
    * 解释：当前面 $n-1$ 堆都满足平均值时，因为总和固定，最后一堆必然自动满足平均值，无需处理。
* **边界情况：**
    * 描述：如果一开始所有堆都已经是平均值，输出应为 0。这一点代码中的 `if (cards[i] == avg) continue;` 已经涵盖。

## 代码关键解释

* `int avg = sum / n;`
    * 算出最终平衡状态下，每堆牌应该是多少。
* `if (cards[i] == avg) continue;`
    * 这是贪心的体现。如果当前堆已经完美，**绝对不要**为了后面的堆而破坏这一堆的平衡（因为总是从左向右处理，破坏了就回不来了），直接跳过。
* `cards[i+1] += cards[i] - avg;`
    * 这是最精髓的一步。将当前堆的“盈余”或“亏损”直接转移给下一堆。
    * 例子：`avg=10`，当前堆 `15`。`diff = 5`。把 `5` 加给下一堆，当前堆逻辑上变成了 `10`（虽然代码没改当前堆，但我们不再访问它了）。
    * 例子：`avg=10`，当前堆 `8`。`diff = -2`。把 `-2` 加给下一堆，相当于下一堆要额外给这一堆 2 张。
* `moves++;`
    * 只要有差额，就意味着必须发生一次交互，计数器加一。

## 💡 复盘与总结

*   **本题收获：**
    1.  **贪心思想的运用**：局部最优（处理好当前这一堆）导致全局最优。
    2.  **化繁为简**：题目描述了移动方向，但实际上我们只需要关心“差额”的流动，而不需要模拟真实的“一张一张移动”。
    3.  **前缀和思想的变种**：本质上，如果前 $i$ 堆的总和不等于 $i \times avg$，那么第 $i$ 堆和第 $i+1$ 堆之间必然有一条切边需要操作。
    4.  **数学建模能力**：将物理世界的移动转化为数组数值的加减传递。

---

## 📝 总结

1. 这道题不要被“移动多少张”迷惑，重点是“要不要移动”。
2. **从左向右扫描**，把问题不断推给下一位，是解决此类线性传递问题的通用解法。
3. 代码实现非常短，但逻辑要清晰，尤其是为什么可以直接把差值加给下一项。
