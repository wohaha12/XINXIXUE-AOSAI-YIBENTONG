# 题目标题：[1321: 【例6.3】删数问题(Noip1994)]

## 时间限制: 1000 ms    内存限制: 65536 KB

## 题目难度：⭐⭐⭐

## 算法标签：[贪心、字符串处理]

## 【题目描述】

输入一个高精度的正整数 $n$（用字符串表示，长度不超过 240 位），去掉其中任意 $s$ 个数字后，剩下的数字按原左右次序组成一个新的正整数。编程对给定的 $n$ 和 $s$，寻找一种方案使得剩下的数字组成的新数最小。

## 【输入】

1. 字符串 $n$。
2. 整数 $s$。

## 【输出】

最后剩下的最小数。

## 【输入样例】

```text
175438
4
```

## 【输出样例】

```text
13
```

## 🧠 解题思路

1. **步骤一：明确贪心目标**
    要让剩下的数最小，核心在于**让高位（左边）的数字尽可能小**。
    举例：对于 `152`，删掉 `5` 变成 `12`，比删掉 `2` 变成 `15` 要优秀。虽然 `5` 和 `2` 都是个位数，但 `5` 在十位上的影响比 `2` 在个位上的影响大得多。

2. **步骤二：确定删除策略（寻找“山峰”）**
    我们不能简单地“删除最大的数字”。例如 `1419`，最大的是 `9`，删掉变成 `141`。但如果删掉 `4`，变成 `119`，明显 `119 < 141`。
    **正确的策略是**：从左往右扫描，找到**第一个**满足 `n[i] > n[i+1]` 的数字 `n[i]` 并删除它。
    * 原因：如果 `n[i] > n[i+1]`，删掉 `n[i]` 后，比它更小的 `n[i+1]` 就会顶替它的位置（高位），从而使整个数变小。

3. **步骤三：循环处理与特殊情况**
    * 我们需要删除 $s$ 个数字，所以上述逻辑需要执行 $s$ 次。
    * **特殊情况**：如果整个数字序列是单调不减的（例如 `12345`），找不到 `n[i] > n[i+1]`，此时为了让数最小，应该删除**最后一个数字**（因为它最大且位权最低）。

## 📊 复杂度分析

* **时间复杂度：O(s * n)**
  * 解释：我们需要进行 $s$ 次删除操作。每次寻找删除点最坏情况需要遍历整个字符串 $n$。由于 $n \le 240$，即使是 $O(n^2)$ 也是极其快速的。
* **空间复杂度：O(n)**
  * 解释：我们需要存储字符串 $n$。

## ⚠️ 易错点与坑点

* **坑点 1：前导零的处理**
  * 描述：删数后可能出现 `0` 开头的情况。例如 `10` 删掉 `1` 变成 `0`。或者 `102` 删掉 `1` 变成 `02`，应该输出 `2`。
  * 解决：处理完所有删除操作后，使用 `while` 循环去除开头的 `0`。
* **坑点 2：结果为 0 的情况**
  * 描述：如果输入 `10` 删 `1` 个，剩下 `0`。去除前导零时小心把这个唯一的 `0` 也删没了，导致输出空。
    *   解决：判断条件应为 `n.length() > 1 && n[0] == '0'`，保留最后一位。
* **边界情况：单调递增序列**
  * 描述：如 `12345` 删 2 个。
  * 逻辑：循环中 `while` 条件不满足，`i` 会增加到最后，删除最后一个字符。正确变为 `123`。

## 代码关键解释

* `while (i < len - 1 && n[i] <= n[i+1]) i++;`
  * 这是寻找“逆序对”的过程。只要当前数字小于等于后面的数字，就继续往后找。一旦停下来，说明要么到了末尾，要么找到了一个 `n[i] > n[i+1]` 的“山峰”。
* `n.erase(i, 1);`
  * C++ string 的 `erase` 方法，从下标 `i` 开始删除 `1` 个字符。这会自动将后面的字符前移。
* `while (n.length() > 1 && n[0] == '0') n.erase(0, 1);`
  * 去前导零的标准写法。

## 💡 复盘与总结

* **本题收获：**
  1. **高位优先原则**：在比较数字大小时，高位的影响力远大于低位。
  2. **局部最优解**：每次只删除**第一个**下降点，是确保每一步操作后数字都达到当前能达到的最小值的关键。
  3. **字符串操作**：熟悉了 `string` 类的 `erase` 用法，处理高精度数字时非常方便。

---

## 📝 总结

1. 这也是一道典型的**贪心**题，核心在于识别出“哪一个数字阻碍了整体变小”。
2. 那个阻碍整体变小的数字，就是**第一个比后面数字大**的数字。
3. 不要忘记处理前导零，这是导致 WA（Wrong Answer）的常见原因。
